@inherits LayoutComponentBase
@inject ThemeService ThemeService
@inject IJSRuntime JSRuntime
@inject BudgetApp.Shared.Services.Interfaces.IAuthService AuthService
@inject BudgetApp.Shared.Services.Interfaces.ISyncService SyncService
@implements IDisposable

<div class="@ThemeService.ThemeClass">
    <HamburgerMenu />

    <div class="app-container">
        @Body
    </div>

    <div id="blazor-error-ui" data-nosnippet>
        An unhandled error has occurred.
        <a href="." class="reload">Reload</a>
        <span class="dismiss">ðŸ—™</span>
    </div>
</div>

@code {
    protected override void OnInitialized()
    {
        ThemeService.OnThemeChanged += OnThemeChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Load saved theme from localStorage
                var savedTheme = await JSRuntime.InvokeAsync<string>("themeHelper.getTheme");
                if (savedTheme == "light")
                {
                    ThemeService.SetTheme(AppTheme.Light);
                }
            }
            catch
            {
                // JS interop not available (e.g., prerendering)
            }

            // â”€â”€ Auto-sync on startup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // If the user is already logged in (e.g., they have a saved token
            // from a previous session), kick off a sync immediately to pull
            // down any changes made on other devices or by the server (Plaid
            // transactions, etc.).  Also start the periodic auto-sync timer.
            //
            // We do this in OnAfterRenderAsync (not OnInitialized) because:
            // 1. It runs after the UI has painted, so the user sees the app
            //    instantly and sync happens in the background.
            // 2. JS interop is available here (needed for some auth token
            //    storage implementations).
            if (AuthService.IsAuthenticated)
            {
                _ = SyncService.SyncAsync();
                SyncService.StartAutoSync(TimeSpan.FromMinutes(5));
            }
        }
    }

    private async void OnThemeChanged()
    {
        // InvokeAsync marshals execution back to Blazor's synchronization
        // context (the "Dispatcher").  StateHasChanged() must run on the
        // UI thread; calling it directly from an event handler that could
        // fire on a background thread throws InvalidOperationException.
        await InvokeAsync(StateHasChanged);
        
        try
        {
            // Save theme to localStorage
            var themeName = ThemeService.IsDarkMode ? "dark" : "light";
            await JSRuntime.InvokeVoidAsync("themeHelper.setTheme", themeName);
        }
        catch
        {
            // JS interop not available
        }
    }

    public void Dispose()
    {
        ThemeService.OnThemeChanged -= OnThemeChanged;

        // Stop the auto-sync timer when the layout is disposed.
        // This prevents background sync from running after the user
        // navigates away or the app is shutting down.
        SyncService.StopAutoSync();
    }
}
